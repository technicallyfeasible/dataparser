(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["DataParser"] = factory();
	else
		root["DataParser"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/release/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Entry point for the DataParser library
	 */

	'use strict';

	module.exports = {
	  PatternMatcher: __webpack_require__(1),
	  DataParser: __webpack_require__(2)
	};

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Matches patterns according to registered rules
	 */

	const arrayUtils = __webpack_require__(10);
	const stringUtils = __webpack_require__(11);
	const Token = __webpack_require__(8);
	const PatternPath = __webpack_require__(7);
	const MatchState = __webpack_require__(3);
	const PathNode = __webpack_require__(5);
	const PatternContext = __webpack_require__(4);

	/** @const */
	const LETTER_CHARACTERS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';

	/**
	 * Create a new pattern matcher with the given base patterns
	 * @param patterns
	 * @constructor
	 */
	function PatternMatcher(patterns) {
	  // All currently active patterns
	  this.patterns = {};
	  // All active patterns compiled for use
	  this.compiledPatterns = {};
	  // All registered validators
	  this.validators = {};

	  if (patterns) {
	    this.addPatterns('', patterns);
	  }
	}

	/**
	 * Clear all compiled patterns
	 */
	PatternMatcher.prototype.clearPatterns = function clearPatterns() {
	  this.patterns.length = 0;
	  this.compiledPatterns.length = 0;
	};

	/**
	 * Add more patterns to the compiled ones
	 * @param matchTag
	 * @param newPatterns
	 */
	PatternMatcher.prototype.addPatterns = function addPatterns(matchTag, newPatterns) {
	  // if no patterns are in the list then there's nothing to do
	  if (!newPatterns || !newPatterns.length) {
	    return;
	  }

	  let targetPatterns = this.patterns[matchTag];
	  if (!targetPatterns) {
	    targetPatterns = this.patterns[matchTag] = [];
	  }

	  let pathRoot = this.compiledPatterns[matchTag];
	  if (!pathRoot) {
	    pathRoot = this.compiledPatterns[matchTag] = {};
	  }

	  // parse each pattern into tokens and then parse the tokens
	  const tokens = [];
	  for (let patternIndex = 0; patternIndex < newPatterns.length; patternIndex++) {
	    const p = newPatterns[patternIndex];

	    // if the pattern was added before then don't do it again
	    if (arrayUtils.contains(targetPatterns, p)) {
	      continue;
	    }

	    const targetIndex = targetPatterns.length;
	    targetPatterns.push(p);

	    const pattern = p.match;

	    //
	    // parse the pattern into tokens
	    //

	    tokens.length = 0;
	    let currentToken = '';
	    let i;
	    for (i = 0; i < pattern.length; i++) {
	      switch (pattern[i]) {
	        case '{':
	          if (!currentToken.length) {
	            break;
	          }
	          tokens.push(new Token(currentToken, true));
	          currentToken = '';
	          break;
	        case '}':
	          tokens.push(new Token(currentToken, false));
	          currentToken = '';
	          break;
	        default:
	          currentToken += pattern[i];
	          break;
	      }
	    }

	    if (currentToken) {
	      tokens.push(new Token(currentToken, true));
	    }

	    if (!tokens.length) {
	      continue;
	    }

	    //
	    // Compile the tokens into the tree
	    //

	    let path = null;
	    let paths = pathRoot;
	    for (i = 0; i < tokens.length; i++) {
	      const token = tokens[i];
	      const tokenKey = token.toString();
	      // check if the exact same node exists and take it if it does
	      let nextPath = paths[tokenKey];
	      if (!nextPath) {
	        nextPath = paths[tokenKey] = new PatternPath();
	      }
	      path = nextPath;
	      paths = nextPath.paths;
	    }
	    if (path) {
	      if (!path.matchedPatterns) {
	        path.matchedPatterns = [];
	      }
	      if (path.matchedPatterns.indexOf(targetIndex) === -1) {
	        path.matchedPatterns.push(targetIndex);
	      }
	    }
	  }
	};

	/**
	 * Match the value against all patterns and return the ones that fit
	 * @param context - The current context for matching
	 * @param value
	 * @returns {*}
	 */
	PatternMatcher.prototype.match = function match(context, value) {
	  var results = [];
	  if (!value) return results;

	  var state = this.matchStart(context, '');
	  for (var i = 0; i < value.length; i++) {
	    var c = value.charAt(i);
	    if (!this.matchNext(state, c)) return results;
	  }

	  results = this.matchResults(state);
	  // reverse results since the longest matches will be found last but are the most specific
	  results.reverse();
	  return results;
	};

	/**
	 * Begin a parsing session
	 * @param context
	 * @param matchTag
	 * @returns {MatchState}
	 */
	PatternMatcher.prototype.matchStart = function matchStart(context, matchTag) {
	  var roots = this.compiledPatterns[matchTag];
	  if (!roots) return null;

	  var state = new MatchState();
	  state.matchTag = matchTag;
	  state.context = context || new PatternContext();

	  var root = new PatternPath();
	  root.paths = roots;
	  var startNode = new PathNode(null, root, '');
	  state.candidatePaths.push(startNode);

	  return state;
	};

	/**
	 * Match the next character
	 * @param state {MatchState} - The current matching state
	 * @param c {String} - The next character
	 * @returns {boolean} - true if this is still a valid match, false otherwise
	 */
	PatternMatcher.prototype.matchNext = function matchNext(state, c) {
	  if (!state) return false;

	  var candidatePaths = state.candidatePaths;
	  var newCandidates = state.newCandidates;
	  for (var i = 0; i < candidatePaths.length; i++) {
	    var candidate = candidatePaths[i];

	    // first check if any of the child nodes validate with the new character and remember them as candidates
	    // any children can only be candidates if the final validation of the current value succeeds
	    if (!candidate.token || this.validateToken(state.context, candidate, true)) this.validateChildren(state.context, candidate.path.paths, candidate, c, newCandidates, 0);

	    // token can be null for the root node but no validation needs to be done for that
	    if (candidate.token != null) {
	      // validate this candidate and remove it if it doesn't validate anymore
	      candidate.isFinalized = false;
	      candidate.textValue += c;
	      if (this.validateToken(state.context, candidate, false)) continue;
	    }
	    candidatePaths.splice(i--, 1);
	  }
	  candidatePaths.push.apply(candidatePaths, newCandidates);
	  newCandidates.length = 0;

	  return candidatePaths.length > 0;
	};

	/**
	 * Assemble the results after the last character has been matched
	 * @param currentState {MatchState} - The current matching state
	 * @returns {Object[]} - The list of matches
	 */
	PatternMatcher.prototype.matchResults = function matchResults(currentState) {};

	/**
	 * Register a validation object for the tag
	 * @param tag
	 * @param validator
	 */
	PatternMatcher.prototype.registerValidator = function registerValidator(tag, validator) {
	  this.validators[tag] = validator;
	};

	/**
	 * Checks whether the value is within the required length for token
	 * @param token
	 * @param value
	 * @param isFinal
	 * @returns {boolean}
	 */
	PatternMatcher.prototype.validateCount = function validateCount(token, value, isFinal) {
	  return (!isFinal || value.length >= token.minCount) && value.length <= token.maxCount;
	};

	/**
	 * Add the next character to the matched path
	 * @param context {PatternContext} - The current matching context
	 * @param node {PathNode} - The node we are validating
	 * @param isFinal {boolean} - True if this is the final match and no further values will be added
	 * @returns {boolean} - true if the value can be parsed successfully using the token
	 */
	PatternMatcher.prototype.validateToken = function validateToken(context, node, isFinal) {
	  // if it is finalized then it is definitely also valid
	  if (node.isFinalized) return true;

	  var token = node.token;
	  var textValue = node.textValue;

	  // match exact values first
	  if (!textValue) return false;
	  if (token.exactMatch) return isFinal && token.value === textValue || !isFinal && stringUtils.startsWith(token.value, textValue);

	  // test inbuilt tokens first
	  switch (token.value) {
	    // whitespace
	    case ' ':
	      return this.validateCount(token, textValue, isFinal) && stringUtils.matchAll(textValue, ' \t');
	    case 'newline':
	      return this.validateCount(token, textValue, isFinal) && stringUtils.matchAll(textValue, '\r\n');
	    case 'emptyline':
	      return this.validateCount(token, textValue, isFinal) && stringUtils.matchAll(textValue, '\r\n \t');
	    case 'letter':
	      return this.validateCount(token, textValue, isFinal) && stringUtils.matchAll(textValue, LETTER_CHARACTERS);
	    case 'any':
	      return this.validateCount(token, textValue, isFinal);
	  }

	  // check pattern tags and do a sub match for each of them
	  if (this.compiledPatterns[token.value]) {
	    // sub matching is possible, so start a new one or continue the previous one
	    if (node.matchState == null) node.matchState = this.matchStart(context, token.value);
	    // if this is the last match then assemble the results
	    if (isFinal) return this.hasResults(node.matchState);
	    return this.matchNext(node.matchState, textValue[textValue.length - 1]);
	  }

	  // check if a validator is registered for this token
	  var validator = this.validators[token.value];
	  if (!validator) return false;

	  return validator.validateToken(token, textValue, isFinal);
	};

	/**
	 * Recursively check candidates
	 * @param context {PatternContext}
	 * @param paths {object[]}
	 * @param node {PathNode}
	 * @param val {string}
	 * @param newCandidates {PathNode[]}
	 * @param depth {number}
	 */
	PatternMatcher.prototype.validateChildren = function validateChildren(context, paths, node, val, newCandidates, depth) {};

	module.exports = PatternMatcher;

	/*

	 /// <summary>
	 /// Matches data based on patterns
	 /// </summary>
	 public class PatternMatcher
	 {
	 private const String LetterCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

	 /// <summary>
	 /// All currently active patterns
	 /// </summary>
	 private readonly Dictionary<String, List<Pattern>> patterns = new Dictionary<String, List<Pattern>>();
	 /// <summary>
	 /// All active patterns compiled for use
	 /// </summary>
	 private readonly Dictionary<String, Dictionary<Token, PatternPath>> compiledPatterns = new Dictionary<String, Dictionary<Token, PatternPath>>();
	 /// <summary>
	 /// All registered validators
	 /// </summary>
	 private readonly Dictionary<String, ITokenValidator> validators = new Dictionary<String, ITokenValidator>();

	 /// <summary>
	 /// Constructor
	 /// </summary>
	 public PatternMatcher(Pattern[] patterns)
	 {
	 if (patterns.Length > 0)
	 AddPatterns("", patterns);
	 }

	 /// <summary>
	 /// Clear all compiled patterns
	 /// </summary>
	 public void ClearPatterns()
	 {
	 this.patterns.Clear();
	 this.compiledPatterns.Clear();
	 }

	 /// <summary>
	 /// Add more patterns to the compiled ones
	 /// </summary>
	 public void AddPatterns(String matchTag, Pattern[] newPatterns)
	 {
	 List<Pattern> targetPatterns;
	 #if SCRIPTSHARP
	 if ((targetPatterns = DictionaryUtils.TryGetPatterns(this.patterns, matchTag)) == null)
	 #else
	 if (!this.patterns.TryGetValue(matchTag, out targetPatterns))
	 #endif
	 this.patterns[matchTag] = targetPatterns = new List<Pattern>(newPatterns.Length);

	 Dictionary<Token, PatternPath> pathRoot;
	 #if SCRIPTSHARP
	 if ((pathRoot = DictionaryUtils.TryGetPatternPath(compiledPatterns, matchTag)) == null)
	 compiledPatterns[matchTag] = pathRoot = new Dictionary<Token, PatternPath>();
	 #else
	 if (!this.compiledPatterns.TryGetValue(matchTag, out pathRoot))
	 this.compiledPatterns[matchTag] = pathRoot = new Dictionary<Token, PatternPath>();
	 #endif

	 // parse each pattern into tokens and then parse the tokens
	 List<Token> tokens = new List<Token>();
	 for (Int32 patternIndex = 0; patternIndex < newPatterns.Length; patternIndex++)
	 {
	 Pattern p = newPatterns[patternIndex];

	 // if the pattern was added before then don't do it again
	 if (targetPatterns.Contains(p))
	 continue;

	 Int32 targetIndex = targetPatterns.Count;
	 targetPatterns.Add(p);

	 String pattern = p.Match;

	 //
	 // parse the pattern into tokens
	 //

	 tokens.Clear();
	 String currentToken = "";
	 Int32 i;
	 for (i = 0; i < pattern.Length; i++)
	 {
	 switch (pattern[i])
	 {
	 case '{':
	 if (currentToken.Length == 0)
	 break;
	 tokens.Add(new Token(currentToken, true));
	 currentToken = "";
	 break;
	 case '}':
	 tokens.Add(new Token(currentToken, false));
	 currentToken = "";
	 break;
	 default:
	 currentToken += pattern[i];
	 break;
	 }
	 }

	 if(!String.IsNullOrEmpty(currentToken))
	 tokens.Add(new Token(currentToken, true));

	 if (tokens.Count == 0)
	 continue;

	 //
	 // Compile the tokens into the tree
	 //

	 PatternPath path = null;
	 Dictionary<Token, PatternPath> paths = pathRoot;
	 for (i = 0; i < tokens.Count; i++)
	 {
	 Token token = tokens[i];
	 // check if the exact same node exists and take it if it does
	 PatternPath nextPath;
	 #if SCRIPTSHARP
	 if ((nextPath = DictionaryUtils.TryGetPath(paths, token)) == null)
	 #else
	 if (!paths.TryGetValue(token, out nextPath))
	 #endif
	 {
	 nextPath = new PatternPath();
	 paths[token] = nextPath;
	 }
	 path = nextPath;
	 paths = nextPath.Paths;
	 }
	 if (path != null)
	 {
	 if (path.MatchedPatterns == null)
	 path.MatchedPatterns = new List<Int32>();
	 if (!path.MatchedPatterns.Contains(targetIndex))
	 path.MatchedPatterns.Add(targetIndex);
	 }
	 }
	 }


	 /// <summary>
	 /// Match the value against all patterns and return the ones that fit
	 /// </summary>
	 /// <param name="value"></param>
	 /// <returns></returns>
	 public List<Object> Match(String value)
	 {
	 return Match(new PatternContext(), value);
	 }

	 /// <summary>
	 /// Match the value against all patterns and return the ones that fit
	 /// </summary>
	 /// <param name="context">The current context for matching</param>
	 /// <param name="value"></param>
	 /// <returns></returns>
	 public List<Object> Match(PatternContext context, String value)
	 {
	 List<Object> results = new List<Object>();
	 if (String.IsNullOrEmpty(value))
	 return results;

	 Object state = MatchStart(context, "");
	 for (int i = 0; i < value.Length; i++)
	 {
	 char c = value[i];
	 if (!MatchNext(state, c))
	 return results;
	 }

	 results = MatchResults(state);
	 // reverse results since the longest matches will be found last but are the most specific
	 results.Reverse();
	 return results;
	 }


	 /// <summary>
	 /// Begin a parsing session
	 /// </summary>
	 /// <param name="context"></param>
	 /// <param name="matchTag"></param>
	 /// <returns></returns>
	 public Object MatchStart(PatternContext context, String matchTag)
	 {
	 Dictionary<Token, PatternPath> roots;
	 #if SCRIPTSHARP
	 if ((roots = DictionaryUtils.TryGetPatternPath(compiledPatterns, matchTag)) == null)
	 #else
	 if (!this.compiledPatterns.TryGetValue(matchTag, out roots))
	 #endif
	 return null;

	 MatchState state = new MatchState();
	 state.MatchTag = matchTag;
	 state.Context = context ?? new PatternContext();

	 PatternPath root = new PatternPath();
	 root.Paths = roots;
	 PathNode startNode = new PathNode(null, root, "");
	 state.CandidatePaths.Add(startNode);

	 return state;
	 }

	 /// <summary>
	 /// Match the next character
	 /// </summary>
	 /// <param name="currentState">The current matching state</param>
	 /// <param name="c">The next character</param>
	 /// <returns>Returns true if this is still a valid match, false otherwise</returns>
	 public Boolean MatchNext(Object currentState, Char c)
	 {
	 MatchState state = currentState as  MatchState;
	 if (state == null)
	 return false;

	 List<PathNode> candidatePaths = state.CandidatePaths;
	 List<PathNode> newCandidates = state.NewCandidates;
	 for (Int32 i = 0; i < candidatePaths.Count; i++)
	 {
	 PathNode candidate = candidatePaths[i];

	 // first check if any of the child nodes validate with the new character and remember them as candidates
	 // any children can only be candidates if the final validation of the current value succeeds
	 if (candidate.Token == null || ValidateToken(state.Context, candidate, true))
	 ValidateChildren(state.Context, candidate.Path.Paths, candidate, c.ToString(CultureInfo.InvariantCulture), newCandidates, 0);

	 // token can be null for the root node but no validation needs to be done for that
	 if (candidate.Token != null)
	 {
	 // validate this candidate and remove it if it doesn't validate anymore
	 candidate.IsFinalized = false;
	 candidate.TextValue += c;
	 if (ValidateToken(state.Context, candidate, false))
	 continue;
	 }
	 candidatePaths.RemoveAt(i--);
	 }
	 candidatePaths.AddRange(newCandidates);
	 newCandidates.Clear();

	 return candidatePaths.Count > 0;
	 }


	 /// <summary>
	 /// Assemble the results after the last character has been matched
	 /// </summary>
	 /// <param name="currentState"></param>
	 /// <returns></returns>
	 public Boolean HasResults(Object currentState)
	 {
	 MatchState state = currentState as MatchState;
	 if (state == null)
	 return false;

	 List<PathNode> candidatePaths = state.CandidatePaths;

	 if (!this.patterns.ContainsKey(state.MatchTag))
	 return false;

	 // fetch patterns for all matching candidates
	 foreach (PathNode path in candidatePaths)
	 {
	 // do final validation
	 if (!ValidateToken(state.Context, path, true))
	 continue;
	 Boolean result = false;
	 MatchToLast(path.Path, delegate { result = true; }, 0);
	 return result;
	 }
	 return false;
	 }


	 /// <summary>
	 /// Assemble the results after the last character has been matched
	 /// </summary>
	 /// <param name="currentState"></param>
	 /// <returns></returns>
	 public List<Object> MatchResults(Object currentState)
	 {
	 List<Object> results = new List<Object>();

	 MatchState state = currentState as MatchState;
	 if (state == null)
	 return results;

	 List<PathNode> candidatePaths = state.CandidatePaths;

	 // get the patterns for this tag
	 List<Pattern> targetPatterns;
	 #if SCRIPTSHARP
	 if ((targetPatterns = DictionaryUtils.TryGetPatterns(patterns, state.MatchTag)) == null)
	 #else
	 if (!this.patterns.TryGetValue(state.MatchTag, out targetPatterns))
	 #endif
	 return results;

	 // fetch patterns for all matching candidates
	 foreach (PathNode path in candidatePaths)
	 {
	 // do final validation
	 if (!ValidateToken(state.Context, path, true))
	 continue;
	 FinalizeValue(path);
	 List<Object> previousValues = new List<Object>(path.PreviousValues);
	 previousValues.Add(path.Value);
	 MatchToLast(path.Path, delegate(PatternPath match, Int32 depth)
	 {
	 // add empty values for remaining tokens
	 Object[] values = new Object[previousValues.Count + depth];
	 for (Int32 i = 0; i < previousValues.Count; i++)
	 values[i] = previousValues[i];
	 for (Int32 m = 0; m < match.MatchedPatterns.Count; m++)
	 {
	 Pattern pattern = targetPatterns[match.MatchedPatterns[m]];
	 Object result = pattern.Parse(state.Context, values);
	 // only add if it is not in the list yet
	 if (!results.Contains(result))
	 results.Add(result);
	 }
	 }, 0);
	 }
	 return results;
	 }

	 private void ValidateChildren(PatternContext context, IEnumerable<KeyValuePair<Token, PatternPath>> paths, PathNode node, String val, List<PathNode> newCandidates, Int32 depth)
	 {
	 // first check if any of the child nodes validate with the new character and remember them as candidates
	 foreach (KeyValuePair<Token, PatternPath> childPath in paths)
	 {
	 PathNode childNode = new PathNode(childPath.Key, childPath.Value, val);
	 // if zero count is allowed it does not matter whether the child validates or not, we always try children as well
	 if (childPath.Key.MinCount == 0)
	 ValidateChildren(context, childPath.Value.Paths, node, val, newCandidates, depth + 1);
	 if (!ValidateToken(context, childNode, false))
	 {
	 // token did not validate but 0 count is allowed
	 //if (childPath.Key.MinCount == 0)
	 //	ValidateChildren(childPath.Value.Paths, node, val, newCandidates, depth + 1);
	 continue;
	 }

	 // validated successfully so add a new candidate
	 // add empty values for all skipped tokens
	 childNode.PreviousValues.AddRange(node.PreviousValues);
	 if (node.Token != null)
	 {
	 FinalizeValue(node);
	 childNode.PreviousValues.Add(node.Value);
	 }
	 for (Int32 i = 0; i < depth; i++)
	 childNode.PreviousValues.Add(null);
	 newCandidates.Add(childNode);
	 }
	 }

	 private void MatchToLast(PatternPath path, Action<PatternPath, Int32> add, Int32 depth)
	 {
	 if (path.MatchedPatterns != null)
	 add(path, depth);
	 // check children if they allow 0 length as well
	 foreach (KeyValuePair<Token, PatternPath> childPath in path.Paths)
	 {
	 if (childPath.Key.MinCount > 0)
	 continue;
	 MatchToLast(childPath.Value, add, depth + 1);
	 }

	 }


	 /// <summary>
	 /// Register a validation object for the tag
	 /// </summary>
	 /// <param name="tag"></param>
	 /// <param name="validator"></param>
	 public void RegisterValidator(String tag, ITokenValidator validator)
	 {
	 this.validators[tag] = validator;
	 }



	 private Boolean ValidateCount(Token token, String value, Boolean isFinal)
	 {
	 return (!isFinal || value.Length >= token.MinCount) && value.Length <= token.MaxCount;
	 }

	 /// <summary>
	 /// Add the next character to the matched path
	 /// </summary>
	 /// <param name="context">The current matching context</param>
	 /// <param name="node">The node we are validating</param>
	 /// <param name="isFinal">True if this is the final match and no further values will be added</param>
	 /// <returns>Returns true if the value can be parsed successfully using the token</returns>
	 private Boolean ValidateToken(PatternContext context, PathNode node, Boolean isFinal)
	 {
	 // if it is finalzed then it is definitely also valid
	 if (node.IsFinalized)
	 return true;

	 Token token = node.Token;
	 String textValue = node.TextValue;

	 // match exact values first
	 if (String.IsNullOrEmpty(textValue))
	 return false;
	 if (token.ExactMatch)
	 return ((isFinal && token.Value == textValue) || (!isFinal && token.Value.StartsWith(textValue)));

	 // test inbuilt tokens first
	 switch (token.Value)
	 {
	 // whitespace
	 case " ":
	 return ValidateCount(token, textValue, isFinal) && StringUtils.MatchAll(textValue, " \t");
	 case "newline":
	 return ValidateCount(token, textValue, isFinal) && StringUtils.MatchAll(textValue, "\r\n");
	 case "emptyline":
	 return ValidateCount(token, textValue, isFinal) && StringUtils.MatchAll(textValue, "\r\n \t");
	 case "letter":
	 return ValidateCount(token, textValue, isFinal) && StringUtils.MatchAll(textValue, LetterCharacters);
	 case "any":
	 return ValidateCount(token, textValue, isFinal);
	 }

	 // check pattern tags and do a sub match for each of them
	 if (this.compiledPatterns.ContainsKey(token.Value))
	 {
	 // sub matching is possible, so start a new one or continue the previous one
	 if (node.MatchState == null)
	 node.MatchState = MatchStart(context, token.Value);
	 // if this is the last match then assemble the results
	 if (isFinal)
	 return HasResults(node.MatchState);
	 return MatchNext(node.MatchState, textValue[textValue.Length - 1]);
	 }

	 // check if a validator is registered for this token
	 ITokenValidator validator;
	 #if SCRIPTSHARP
	 if ((validator = DictionaryUtils.TryGetValidators(validators, token.Value)) == null)
	 #else
	 if (!this.validators.TryGetValue(token.Value, out validator))
	 #endif
	 return false;

	 return validator.ValidateToken(token, textValue, isFinal);
	 }


	 /// <summary>
	 /// Parses the TextValue of the node into the final value
	 /// </summary>
	 /// <param name="node"></param>
	 /// <returns>Returns true if successful, false if the TextValue is not valid</returns>
	 private void FinalizeValue(PathNode node)
	 {
	 // already finalized
	 if (node.IsFinalized)
	 return;

	 Token token = node.Token;
	 String textValue = node.TextValue;

	 if (token.ExactMatch || token.Value == " " || token.Value == "newline" || token.Value == "emptyline" || token.Value == "letter")
	 {
	 node.Value = textValue;
	 node.IsFinalized = true;
	 return;
	 }

	 // check pattern tags and do a sub match for each of them
	 if (this.compiledPatterns.ContainsKey(token.Value) && node.MatchState != null)
	 {
	 node.Value = null;
	 List<Object> results = MatchResults(node.MatchState);
	 if (results.Count == 0)
	 return;
	 // TODO: can be multiple results, choose the correct one depending on user culture
	 node.Value = results[0];
	 node.IsFinalized = true;
	 return;
	 }

	 // check if a validator is registered for this token
	 ITokenValidator validator;
	 #if SCRIPTSHARP
	 if ((validator = DictionaryUtils.TryGetValidators(validators, token.Value)) != null)
	 #else
	 if (this.validators.TryGetValue(token.Value, out validator))
	 #endif
	 {
	 node.Value = validator.FinalizeValue(token, textValue);
	 node.IsFinalized = true;
	 }
	 }
	 }
	 */

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Parses data values to figure out what actual type they are
	 */

	/**
	 * @class Module
	 * @type {object}
	 * @property {string[]} patternTags - available pattern tags
	 * @property {string[]} tokenTags - available token tags
	 * @property {function(string)} getPatterns - returns patterns for a tag
	 */

	'use strict';

	var PatternMatcher = __webpack_require__(1);

	var moduleTypes = [__webpack_require__(9)
	/*require('./modules/NumberParserModule'),
	require('./modules/DateParserModule'),
	require('./modules/AddressParserModule'),
	require('./modules/CurrencyParserModule'),
	require('./modules/UrlParserModule'),
	require('./modules/IpParserModule'),
	require('./modules/EmailParserModule')*/
	];
	//var dateModuleTypes = [
	/*require('./modules/NumberParserModule'),
	require('./modules/DateParserModule')*/
	//];

	var defaultPatternMatcher = null;
	//var datePatternMatcher = null;
	var namedPatternMatchers = {};

	/**
	 * Create a new PatternMatcher object including the specified modules
	 * @param modules {Module[]} - List of modules to include
	 * @returns {PatternMatcher}
	 * @constructor
	 */
	function makePatternMatcher(modules) {
		var matcher = new PatternMatcher([]);
		if (!modules) return matcher;

		modules.forEach(function (Module) {
			var module = new Module();
			var i, tag;

			// add patterns
			for (i = 0; i < module.patternTags.length; i++) {
				tag = module.patternTags[i];
				matcher.addPatterns(tag, module.getPatterns(tag));
			}

			// register validators
			for (i = 0; i < module.tokenTags.length; i++) {
				tag = module.tokenTags[i];
				matcher.registerValidator(tag, module);
			}
		});
		return matcher;
	}

	/**
	 * Make sure the default pattern matcher including all patterns is available and return it
	 * @returns {PatternMatcher}
	 */
	function getDefaultPatternMatcher() {
		if (!defaultPatternMatcher) defaultPatternMatcher = makePatternMatcher(moduleTypes);
		return defaultPatternMatcher;
	}

	/**
	 * Create a data parser with the specified name and modules. If name and modules is empty, matches all default patterns.
	 * @param name
	 * @param modules
	 * @constructor
	 */
	var DataParser = function (name, modules) {
		if (!name || !modules) {
			this.patternMatcher = getDefaultPatternMatcher();
		} else {
			if (namedPatternMatchers[name]) return;

			this.patternMatcher = makePatternMatcher(modules);
			namedPatternMatchers[name] = this.patternMatcher;
		}
	};

	/*
	{
		private static readonly Type[] ModuleTypes =
		{
			typeof(NumberParserModule), typeof(DateParserModule), typeof(AddressParserModule), typeof(CurrencyParserModule), typeof(BooleanParserModule),
			typeof(UrlParserModule), typeof(IpParserModule), typeof(EmailParserModule)
		};
		private static readonly Type[] DateModuleTypes =
		{
			typeof(NumberParserModule), typeof(DateParserModule)
		};
		private static readonly PatternMatcher DefaultPatternMatcher;
		private static readonly PatternMatcher DatePatternMatcher;
		private static readonly Dictionary<String, PatternMatcher> NamedPatternMatchers = new Dictionary<String, PatternMatcher>();

		private readonly PatternMatcher patternMatcher;

		/// <summary>
		/// Default context for parsing
		/// </summary>
		public PatternContext DefaultPatternContext { get; set; }

		/// <summary>
		/// Load all patterns from the defined modules
		/// </summary>
		static DataParser()
		{
			DefaultPatternMatcher = makePatternMatcher(ModuleTypes);
			DatePatternMatcher = makePatternMatcher(DateModuleTypes);
		}

		/// <summary>
		/// Use the default pattern matcher
		/// </summary>
		public DataParser()
		{
			this.patternMatcher = DefaultPatternMatcher;
		}

		/// <summary>
		/// Load all patterns from the defined modules
		/// </summary>
		public DataParser(String name, Type[] modules)
		{
			if (String.IsNullOrEmpty(name) || modules == null)
			{
				this.patternMatcher = DefaultPatternMatcher;
				return;
			}

			if (NamedPatternMatchers.TryGetValue(name, out this.patternMatcher) && this.patternMatcher != null)
				return;

			this.patternMatcher = makePatternMatcher(modules);
			NamedPatternMatchers[name] = this.patternMatcher;
		}


		private static PatternMatcher makePatternMatcher(Type[] modules)
		{
			PatternMatcher matcher = new PatternMatcher(new Pattern[0]);

			foreach (Type moduleType in modules)
			{
				IParserModule module = Activator.CreateInstance(moduleType) as IParserModule;
				if (module == null) continue;

				// add patterns
				foreach (String tag in module.PatternTags)
					matcher.AddPatterns(tag, module.GetPatterns(tag));

				// register validators
				foreach (String tag in module.TokenTags)
					matcher.RegisterValidator(tag, module);
			}
			return matcher;
		}

		/// <summary>
		/// Parse a value into all possible native types
		/// </summary>
		/// <param name="value"></param>
		/// <returns></returns>
		public List<IValue> Parse(String value)
		{
			return Parse(DefaultPatternContext ?? new PatternContext(), value);
		}

		/// <summary>
		/// Parse a value into all possible native types
		/// </summary>
		/// <param name="context"></param>
		/// <param name="value"></param>
		/// <returns></returns>
		public List<IValue> Parse(PatternContext context, String value)
		{
			List<Object> matchResults = this.patternMatcher.Match(context, value);
			return (matchResults == null ? new List<IValue>() : matchResults.Cast<IValue>().ToList());
		}

		/// <summary>
		/// Parse a value as a LocalDate
		/// </summary>
		/// <param name="value"></param>
		/// <returns></returns>
		public LocalDate ParseDate(String value)
		{
			return ParseDate(DefaultPatternContext ?? new PatternContext(), value);
		}

		/// <summary>
		/// Parse a value as a LocalDate
		/// </summary>
		/// <param name="context"></param>
		/// <param name="value"></param>
		/// <returns></returns>
		public LocalDate ParseDate(PatternContext context, String value)
		{
			List<Object> results = DatePatternMatcher.Match(context, value);
			LocalDate dateResult = results.OfType<LocalDate>().FirstOrDefault();
			return dateResult;
		}
	}
	*/

	module.exports = DataParser;

/***/ },
/* 3 */
/***/ function(module, exports) {

	/**
	 * Holds state for a matching session
	 */

	'use strict';

	var MatchState = function () {
		this.matchTag = null;
		this.candidatePaths = [];
		this.newCandidates = [];

		this.context = null;
	};

	module.exports = MatchState;

	/*
		internal class MatchState
		{
			public String MatchTag;
			public List<PathNode> CandidatePaths = new List<PathNode>();
			public List<PathNode> NewCandidates = new List<PathNode>();

			public PatternContext Context { get; set; }
		}
	*/

/***/ },
/* 4 */
/***/ function(module, exports) {

	/**
	 * Context for pattern matching
	 * Holds values which may influence parsing outcome like current date and time, location or language
	 */

	'use strict';

	var PatternContext = function (currentDate) {
		this.currentDate = currentDate || new Date();
	};

	module.exports = PatternContext;

	/*
		public class PatternContext
		{
			public LocalDate CurrentDate { get; set; }

			public PatternContext()
			{
				CurrentDate = new LocalDate(DateTime.UtcNow);
			}

			public PatternContext(LocalDate currentDate)
			{
				CurrentDate = currentDate;
			}
		}
	*/

/***/ },
/* 5 */
/***/ function(module, exports) {

	/**
	 * A node in the current parsing session
	 */

	'use strict';

	/**
	 * Create a new node to hold parsing state
	 * @param token
	 * @param path
	 * @param textValue
	 * @constructor
	 */

	var PathNode = function (token, path, textValue) {
		// The token for comparison
		this.token = token;

		// The matching path for going deeper
		this.path = path;

		// The value which still matches this path
		this.textValue = textValue;

		// The final assembled value
		this.value = null;
		// All values of earlier tokens
		this.previousValues = [];

		// True if the value has been finalized and assigned
		this.isFinalized = null;

		// Remember the current state of any matching algorithm
		this.matchState = null;
	};

	PathNode.prototype.toString = function () {
		return this.textValue + ' = ' + this.token;
	};

	module.exports = PathNode;

	/*
		internal class PathNode
		{
			public override string ToString()
			{
				return String.Format("{0} = {1}", this.TextValue, this.Token);
			}

			/// <summary>
			/// The token for comparison
			/// </summary>
			public Token Token;

			/// <summary>
			/// The matching path for going deeper
			/// </summary>
			public PatternPath Path;

			/// <summary>
			/// The value which still matches this path
			/// </summary>
			public String TextValue;

			/// <summary>
			/// The final assembled value
			/// </summary>
			public Object Value;
			/// <summary>
			/// All values of earlier tokens
			/// </summary>
			public List<Object> PreviousValues = new List<Object>();

			/// <summary>
			/// True if the value has been finalized and assigned
			/// </summary>
			public Boolean IsFinalized;

			/// <summary>
			/// Remember the current state of any matching algorithm
			/// </summary>
			public Object MatchState;

			public PathNode(Token token, PatternPath path, String textValue)
			{
				this.Token = token;
				this.Path = path;
				this.TextValue = textValue;
			}
		}
	*/

/***/ },
/* 6 */
/***/ function(module, exports) {

	/**
	 * Pattern object
	 */

	'use strict';

	var Pattern = function (match, parser) {
		this.match = match || '';
		this.parser = parser;
	};

	Pattern.prototype.toString = function () {
		return this.match;
	};
	Pattern.prototype.parse = function (context, values) {
		return this.parser(context, values);
	};
	Pattern.prototype.equals = function (other) {
		if (!other) return false;
		return this.match === other.match;
	};

	module.exports = Pattern;

	/*
		public class Pattern
		{
			public String Match { get; private set; }
			public Func<PatternContext, Object[], Object> Parser { get; private set; }
			public Func<Object[], Object> ParserNoContext { get; private set; }

			public Pattern(String match, Func<Object[], Object> parser)
			{
				Match = match;
				ParserNoContext = parser;
			}
			public Pattern(String match, Func<PatternContext, Object[], Object> parser)
			{
				Match = match;
				Parser = parser;
			}

			public Object Parse(PatternContext context, Object[] values)
			{
				if (ParserNoContext != null)
					return ParserNoContext(values);
				return Parser(context, values);
			}

	#if !SCRIPTSHARP
			public override Boolean Equals(Object obj)
			{
				if (ReferenceEquals(null, obj)) return false;
				if (ReferenceEquals(this, obj)) return true;
				if (obj.GetType() != GetType()) return false;
				return Equals((Pattern) obj);
			}

			protected Boolean Equals(Pattern other)
			{
				return String.Equals(Match, other.Match);
			}

			public override Int32 GetHashCode()
			{
				return (Match != null ? Match.GetHashCode() : 0);
			}

			public override String ToString()
			{
				return Match;
			}
	#endif
	*/

/***/ },
/* 7 */
/***/ function(module, exports) {

	/**
	 * Keeps tree information for patterns
	 */

	'use strict';

	/**
	 * Create a new patch
	 * @constructor
	 */

	var PatternPath = function () {
		// Paths for all tokens
		this.paths = {};
		// Any patterns finishing at this path
		this.matchedPatterns = [];
	};
	PatternPath.prototype.toString = function () {
		var matches = (this.matchedPatterns || []).join(', ');
		var children = this.paths.map(function (token) {
			return token.toString();
		}).join(', ');
		return matches + ' :: ' + children;
	};

	module.exports = PatternPath;

	/*
		internal class PatternPath
		{
	#if !SCRIPTSHARP
			public override String ToString()
			{
				var matches = String.Join(", ", this.MatchedPatterns ?? new List<Int32>(0));
				var children = String.Join(", ", this.Paths.Keys.Select(t => t.ToString()));
				return String.Format("{0} :: {1}", matches, children);
			}
	#endif

			public Dictionary<Token, PatternPath> Paths = new Dictionary<Token, PatternPath>();

			/// <summary>
			/// Any patterns finishing at this path
			/// </summary>
			public List<Int32> MatchedPatterns;
		}
	*/

/***/ },
/* 8 */
/***/ function(module, exports) {

	/**
	 * Token value for parsed patterns
	 */

	'use strict';

	/**
	 * Creates a new Token
	 * @param value {string}
	 * @param exactMatch {boolean}
	 * @constructor
	 */

	var Token = function (value, exactMatch) {
		this.exactMatch = !!exactMatch;
		if (this.exactMatch) {
			this.value = value;
			this.minCount = this.maxCount = 1;
			return;
		}

		var parts = (value || '').split(':');
		this.value = parts.length > 0 ? parts[0] : '';
		if (parts.length === 1) this.minCount = this.maxCount = 1;else if (parts.length > 1) {
			switch (parts[1]) {
				case '':
					this.minCount = 1;
					this.maxCount = 1;
					break;
				case '+':
					this.minCount = 1;
					this.maxCount = this.MAX_VALUE;
					break;
				case '*':
					this.minCount = 0;
					this.maxCount = this.MAX_VALUE;
					break;
				case '?':
					this.minCount = 0;
					this.maxCount = 1;
					break;
				default:
					var countParts = parts[1].split('-');
					if (countParts.length === 1) this.minCount = this.maxCount = parseInt(countParts[0]);else if (countParts.length >= 2) {
						this.minCount = parseInt(countParts[0] || '0');
						this.maxCount = parseInt(countParts[1] || '0');
					}
					break;
			}
		}
		// don't allow max to be smaller than min
		if (this.maxCount < this.minCount) this.maxCount = this.minCount;
	};
	/**
	 * Maximum times that a token without restriction can be repeated
	 * @const
	 */
	Token.prototype.MAX_VALUE = 1000;

	Token.prototype.equals = function (token) {
		if (!token) return false;
		return token.value === this.value && token.minCount === this.minCount && token.maxCount === this.maxCount && token.exactMatch === this.exactMatch;
	};
	Token.prototype.toString = function () {
		if (this.exactMatch) return this.value;
		return this.value + ':' + this.minCount + '-' + this.maxCount;
	};

	module.exports = Token;

	/*
		public class Token
		{
			public String Value;
			public Int32 MinCount;
			public Int32 MaxCount;
			public Boolean ExactMatch;

			/// <summary>
			/// Parse the token
			/// </summary>
			/// <param name="value"></param>
			/// <param name="exactMatch"></param>
			public Token(String value, Boolean exactMatch)
			{
				if (exactMatch)
				{
					this.Value = value;
					this.MinCount = this.MaxCount = 1;
					this.ExactMatch = true;
					return;
				}

	#if !SCRIPTSHARP
				String[] parts = value.Split(new Char[] { ':' }, StringSplitOptions.RemoveEmptyEntries);
	#else
				String[] parts = StringUtils.Split(value, ':');
	#endif
				this.Value = parts[0];
				if (parts.Length == 1)
					this.MinCount = this.MaxCount = 1;
				else if (parts.Length > 1)
				{
					switch (parts[1])
					{
						case "":
							this.MinCount = 1;
							this.MaxCount = 1;
							break;
						case "+":
							this.MinCount = 1;
							this.MaxCount = Int32.MaxValue;
							break;
						case "*":
							this.MinCount = 0;
							this.MaxCount = Int32.MaxValue;
							break;
						case "?":
							this.MinCount = 0;
							this.MaxCount = 1;
							break;
						default:
							String[] countParts = parts[1].Split('-');
							if (countParts.Length == 1)
								this.MinCount = this.MaxCount = Int32.Parse(countParts[0]);
							else if (countParts.Length == 2)
							{
								this.MinCount = Int32.Parse(countParts[0]);
								this.MaxCount = Int32.Parse(countParts[1]);
							}
							break;
					}
				}
			}

	#if !SCRIPTSHARP
			public override Boolean Equals(object obj)
			{
				if (ReferenceEquals(null, obj)) return false;
				if (ReferenceEquals(this, obj)) return true;
				if (obj.GetType() != GetType()) return false;
				return Equals((Token)obj);
			}

			protected bool Equals(Token other)
			{
				return string.Equals(this.Value, other.Value) && this.MinCount == other.MinCount && this.MaxCount == other.MaxCount && this.ExactMatch.Equals(other.ExactMatch);
			}

			public override int GetHashCode()
			{
				unchecked
				{
					int hashCode = (this.Value != null ? this.Value.GetHashCode() : 0);
					hashCode = (hashCode * 397) ^ this.MinCount;
					hashCode = (hashCode * 397) ^ this.MaxCount;
					hashCode = (hashCode * 397) ^ this.ExactMatch.GetHashCode();
					return hashCode;
				}
			}

			public override String ToString()
			{
				if (this.ExactMatch)
					return String.Format("{0}", this.Value);
				return String.Format("{0}:{1}-{2}", this.Value, this.MinCount, this.MaxCount);
			}
	#endif
		}
	*/

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Validates booleans
	 */

	'use strict';

	var Pattern = __webpack_require__(6);
	var BooleanValue = __webpack_require__(12);

	/**
	 * Make the final output value
	 * @param value
	 * @returns {BooleanValue}
	 */
	function make(value) {
		var boolValue = false;
		if (typeof value === 'boolean') boolValue = value;else if (value) {
			var lowerValue = value.toString().toLowerCase();
			boolValue = this.const.trueValues.indexOf(lowerValue) !== -1;
		}
		return new BooleanValue(boolValue);
	}
	/**
	 * Reusable wrapper for the two patterns
	 * @param v
	 */
	function parsePattern(v) {
		make(v[1]);
	}

	var mainPatterns = [new Pattern('{emptyline:*}{booleantrue}{emptyline:*}', parsePattern), new Pattern('{emptyline:*}{booleanfalse}{emptyline:*}', parsePattern)];

	/**
	 * Singleton Module to parse boolean values
	 * @constructor
	 */
	var BooleanParserModule = function () {
		this.const = {
			trueValues: ['1', 'true', 'wahr'],
			falseValues: ['0', 'false', 'falsch']
		};

		this.patternTags = [''];
		this.tokenTags = ['booleanfalse', 'booleantrue'];
	};
	/**
	 * Return the patterns for the tag
	 * @param tag {string}
	 */
	BooleanParserModule.prototype.getPatterns = function (tag) {
		if (tag === '') return mainPatterns;
		return [];
	};

	module.exports = BooleanParserModule;

	/*
		public class BooleanParserModule : IParserModule
		{
			private static readonly HashSet<String> TrueValues = new HashSet<String> { "true", "wahr" };
			private static readonly HashSet<String> FalseValues = new HashSet<String> { "false", "falsch" };

			private static readonly Pattern[] MainPatterns =
	        {
	            new Pattern("{emptyline:*}{booleantrue}{emptyline:*}", v => Make(v[1])),
	            new Pattern("{emptyline:*}{booleanfalse}{emptyline:*}", v => Make(v[1]))
	        };


			/// <summary>
			/// Make the final output value
			/// </summary>
			/// <param name="value"></param>
			/// <returns></returns>
			private static BooleanValue Make(Object value)
			{
				var boolValue = false;
				if (value is Boolean)
					boolValue = (Boolean) value;
				if (value != null)
				{
					String lowerValue = value.ToString().ToLower();
					boolValue = TrueValues.Contains(lowerValue);
				}
				return new BooleanValue(boolValue);
			}


			/// <summary>
			/// Returns the defined tags for which patterns exist
			/// </summary>
			public String[] PatternTags
			{
				get { return new[] { "" }; }
			}

			/// <summary>
			/// Get the patterns for a specific tag
			/// </summary>
			/// <param name="patternTag"></param>
			/// <returns></returns>
			public Pattern[] GetPatterns(String patternTag)
			{
				switch (patternTag)
				{
					case "":
						return MainPatterns;
				}
				return new Pattern[0];
			}

			/// <summary>
			/// Returns the defined tags which can be parsed as tokens
			/// </summary>
			public String[] TokenTags
			{
				get { return new[] { "booleanfalse", "booleantrue" }; }
			}

			/// <summary>
			/// Callback handler when a value has to be validated against a token
			/// </summary>
			/// <param name="token">The token to validate against</param>
			/// <param name="value">The value to validate</param>
			/// <param name="isFinal">True if this is the final validation and no more characters are expected for the value</param>
			/// <returns>Returns true if the value matches the token, false if it doesn't match or the token is unknown</returns>
			public Boolean ValidateToken(Token token, String value, Boolean isFinal)
			{
				String lowerValue = value.ToLower();
				switch (token.Value)
				{
					case "booleantrue":
						return (isFinal && TrueValues.Contains(lowerValue)) || (!isFinal && StartsWith(TrueValues, lowerValue));
					case "booleanfalse":
						return (isFinal && FalseValues.Contains(lowerValue)) || (!isFinal && StartsWith(FalseValues, lowerValue));
				}

				return false;
			}

			/// <summary>
			/// Parses the TextValue of the node into the final value
			/// </summary>
			/// <param name="token">The token to finalize</param>
			/// <param name="value">The text value to parse</param>
			/// <returns>Returns the parsed result</returns>
			public Object FinalizeValue(Token token, String value)
			{
				switch (token.Value)
				{
					case "booleantrue":
						return true;
					case "booleanfalse":
						return false;
				}
				return value;
			}

			private Boolean StartsWith(IEnumerable<String> allowedValues, String value)
			{
				foreach (String allowedValue in allowedValues)
				{
					if (allowedValue.StartsWith(value))
						return true;
				}
				return false;
			}
		}
	}
	*/

/***/ },
/* 10 */
/***/ function(module, exports) {

	/**
	 * Created by Jens on 26.06.2015.
	 * Provides utilities for arrays such as checking whether an object supporting the Equals interface is contained
	 */

	'use strict';

	var arrayUtils = {
		/**
	  * Checks whether the array contains obj using a custom comparer if available
	  * @param ar {{equals: function}[]}
	  * @param obj {{equals: function}}
	  * @returns {boolean}
	  */
		contains: function (ar, obj) {
			if (!ar) return false;
			// check strict equality first, should be fastest
			if (ar.indexOf(obj) !== -1) return true;

			var hasEquals = !!obj && typeof obj.equals === 'function';

			// check all elements
			for (var i = 0; i < ar.length; i++) {
				var other = ar[i];
				var result;
				if (hasEquals) result = obj.equals(other);else if (typeof other.equals === 'function') result = other.equals(obj);else result = obj === other;
				if (result) return true;
			}
			return false;
		}
	};

	module.exports = arrayUtils;

/***/ },
/* 11 */
/***/ function(module, exports) {

	/**
	 * Created by Jens on 26.06.2015.
	 * Provides utilities for strings
	 */

	'use strict';

	var stringUtils = {
		/**
	  * Checks whether str starts with val
	  * @param str {string}
	  * @param val {string}
	  * @returns {boolean}
	  */
		startsWith: function (str, val) {
			return !!str && !!val && str.length > val.length && str.indexOf(val) === 0;
		},

		/**
	  * Match all characters in the string against all characters in the given array or string
	  * @param str {string} - The string to test
	  * @param chars {string|string[]} - The characters to test for
	  * @param startIndex {number=} - Index of the first character to test
	  * @returns {boolean} - true if all characters in the string are contained in chars
	  */
		matchAll: function (str, chars, startIndex) {
			if (!str || !chars) return false;
			for (var i = startIndex || 0; i < str.length; i++) {
				var c = str.charAt(i);
				if (chars.indexOf(c) === -1) return false;
			}
			return true;
		}

	};

	module.exports = stringUtils;

/***/ },
/* 12 */
/***/ function(module, exports) {

	/**
	 * Boolean result wrapper
	 */

	'use strict';

	var BooleanValue = function (value) {
		this.bool = !!value;
	};
	BooleanValue.prototype.valueOf = function () {
		return this.bool;
	};
	BooleanValue.prototype.toString = function () {
		return this.bool.toString();
	};
	BooleanValue.prototype.equals = function (other) {
		if (!(other instanceof BooleanValue)) return false;
		return this.bool === other.bool;
	};

	module.exports = BooleanValue;

	/*
		public struct BooleanValue : IValue
		{
			/// <summary>
			/// The boolean value
			/// </summary>
			[JsonProperty("v")]
			public Boolean Bool;


			/// <summary>
			/// Generic access to the most prominent value .net type
			/// </summary>
			public Object Value
			{
				get { return Bool; }
				set { Bool = (Boolean)value; }
			}



			/// <summary>
			/// Serialize the value to binary data
			/// </summary>
			/// <returns></returns>
			public Byte[] ToBinary()
			{
				return BitConverter.GetBytes(Bool);
			}

			/// <summary>
			/// Read the value data from binary
			/// </summary>
			/// <param name="data"></param>
			public void FromBinary(Byte[] data)
			{
				Bool = BitConverter.ToBoolean(data, 0);
			}


			/// <summary>
			/// Constructor
			/// </summary>
			/// <param name="value"></param>
			public BooleanValue(Boolean value)
			{
				this.Bool = value;
			}

			public override String ToString()
			{
				return String.Format("{0}", this.Bool);
			}

			public override Boolean Equals(object obj)
			{
				if (!(obj is BooleanValue))
					return false;
				BooleanValue other = (BooleanValue)obj;
				return this.Bool.Equals(other.Bool);
			}

			public override int GetHashCode()
			{
				unchecked
				{
					return this.Bool.GetHashCode();
				}
			}

			public static bool operator ==(BooleanValue a, BooleanValue b)
			{
				return a.Bool.Equals(b.Bool);
			}

			public static bool operator !=(BooleanValue a, BooleanValue b)
			{
				return !a.Bool.Equals(b.Bool);
			}
		}
	*/

/***/ }
/******/ ])
});
;